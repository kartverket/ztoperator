apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: auth-policy-login
spec:
  configPatches:
    - applyTo: HTTP_FILTER
      match:
        context: SIDECAR_INBOUND
        listener:
          filterChain:
            filter:
              name: envoy.filters.network.http_connection_manager
      patch:
        operation: INSERT_BEFORE
        value:
          name: envoy.filters.http.lua
          typed_config:
            '@type': type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
            default_source_code:
              inline_string: |-
                local ignore_rules = {}
                local require_rules = {{regex="^/other/oauth2/callback$",methods={}},{regex="^/other/logout$",methods={}}}
                local deny_redirect_rules = {}
                local authorize_endpoint = "http://mock-oauth2.auth:8080/entraid/authorize"
                local login_params = {}
                local end_session_endpoint = "http://mock-oauth2.auth:8080/entraid/endsession"
                local post_logout_redirect_uri = ""
                
                -- returns true when {p,m} matches any rule in the supplied table
                local function match(rules, p, m)
                    for _, rule in ipairs(rules) do
                        if string.match(p, rule.regex) then
                        -- empty "methods" table == all methods
                            if next(rule.methods) == nil or rule.methods[m] then
                                return true
                            end
                        end
                    end
                    return false
                end
                
                -- returns true if {p,m} is in ignore_rules *and* NOT in require_rules
                local function should_bypass(p, m)
                    local bypass = false
                    if p ~= "" and m ~= "" then
                        -- bypass only when it is in ignore_rules *and* NOT in require_rules
                        if match(ignore_rules, p, m) and not match(require_rules, p, m) then
                            bypass = true
                        end
                    end
                    return bypass
                end
                
                -- returns true if {p,m} is in deny_redirect_rules
                local function should_deny_redirect(p, m)
                    local deny_redirect = false
                    if p ~= "" and m ~= "" then
                        -- deny redirect only when it is in deny_redirect_rules
                        if match(deny_redirect_rules, p, m) then
                            deny_redirect = true
                        end
                    end
                    return deny_redirect
                end
                
                local function is_empty_table(t)
                    return type(t) ~= "table" or next(t) == nil
                end
                
                function envoy_on_request(request_handle)
                    local raw_p = request_handle:headers():get(":path") or ""
                    local m = request_handle:headers():get(":method") or ""
                    local p = string.match(raw_p, "^[^?]*")
                
                    local bypass = should_bypass(p, m)
                    request_handle:logCritical("Login bypassed?: " .. tostring(bypass))
                    request_handle:headers():add("x-bypass-login", tostring(bypass))
                
                    local deny_redirect = should_deny_redirect(p, m)
                    request_handle:logCritical("Deny redirect?: " .. tostring(deny_redirect))
                    request_handle:headers():add("x-deny-redirect", tostring(deny_redirect))
                end
                
                function envoy_on_response(response_handle)
                    local status = response_handle:headers():get(":status") or ""
                    if status == "302" then
                        local loc = response_handle:headers():get("location") or ""
                        if loc ~= "" then
                            if string.sub(loc, 1, #authorize_endpoint) == authorize_endpoint and not is_empty_table(login_params) then
                                local base, qs = loc:match("^([^?]+)%??(.*)$")
                                local filtered = {}
                                if qs ~= "" then
                                    local params = {}
                                    for key, val in string.gmatch(qs, "([^&=?]+)=([^&=?]+)") do
                                        params[key] = val
                                    end
                                    for k, v in pairs(login_params) do
                                        params[k] = v
                                    end
                                    for k, v in pairs(params) do
                                        table.insert(filtered, k .. "=" .. v)
                                    end
                                end
                
                                local new_qs = table.concat(filtered, "&")
                                local new_url = base .. (new_qs ~= "" and ("?" .. new_qs) or "")
                                response_handle:headers():replace("location", new_url)
                            end
                
                            if string.sub(loc, 1, #end_session_endpoint) == end_session_endpoint then
                                local base, qs = loc:match("^([^?]+)%??(.*)$")
                                local filtered = {}
                                if qs ~= "" then
                                    local params = {}
                                    for key, val in string.gmatch(qs, "([^&=?]+)=([^&=?]+)") do
                                        params[key] = val
                                    end
                                    if post_logout_redirect_uri == "" then
                                        params["post_logout_redirect_uri"] = nil
                                    else
                                        params["post_logout_redirect_uri"] = post_logout_redirect_uri
                                    end
                                    for k, v in pairs(params) do
                                        table.insert(filtered, k .. "=" .. v)
                                    end
                                end
                
                                local new_qs = table.concat(filtered, "&")
                                local new_url = base .. (new_qs ~= "" and ("?" .. new_qs) or "")
                                response_handle:headers():replace("location", new_url)
                            end
                        end
                    end
                end
    - applyTo: CLUSTER
      match:
        cluster:
          service: oauth
      patch:
        operation: ADD
        value:
          connect_timeout: 10s
          dns_lookup_family: V4_ONLY
          lb_policy: ROUND_ROBIN
          load_assignment:
            cluster_name: oauth
            endpoints:
              - lb_endpoints:
                  - endpoint:
                      address:
                        socket_address:
                          address: mock-oauth2.auth
                          port_value: 8080
          name: oauth
          type: LOGICAL_DNS
    - applyTo: HTTP_FILTER
      match:
        context: SIDECAR_INBOUND
        listener:
          filterChain:
            filter:
              name: envoy.filters.network.http_connection_manager
              subFilter:
                name: envoy.filters.http.jwt_authn
      patch:
        operation: INSERT_BEFORE
        value:
          name: envoy.filters.http.oauth2
          typed_config:
            '@type': type.googleapis.com/envoy.extensions.filters.http.oauth2.v3.OAuth2
            config:
              auth_scopes:
                - openid
              authorization_endpoint: http://mock-oauth2.auth:8080/entraid/authorize
              credentials:
                client_id: entraid_server
                hmac_secret:
                  name: hmac
                  sds_config:
                    path_config_source:
                      path: /etc/istio/config/hmac-secret.yaml
                      watched_directory:
                        path: /etc/istio/config
                token_secret:
                  name: token
                  sds_config:
                    path_config_source:
                      path: /etc/istio/config/token-secret.yaml
                      watched_directory:
                        path: /etc/istio/config
              deny_redirect_matcher:
                - name: x-deny-redirect
                  string_match:
                    exact: "true"
              end_session_endpoint: http://mock-oauth2.auth:8080/entraid/endsession
              forward_bearer_token: true
              pass_through_matcher:
                - name: authorization
                  string_match:
                    prefix: 'Bearer '
                - name: x-bypass-login
                  string_match:
                    exact: "true"
              redirect_path_matcher:
                path:
                  exact: /other/oauth2/callback
              redirect_uri: https://%REQ(:authority)%/other/oauth2/callback
              retry_policy: {}
              signout_path:
                path:
                  exact: /other/logout
              token_endpoint:
                cluster: oauth
                timeout: 5s
                uri: http://mock-oauth2.auth:8080/entraid/token
              use_refresh_token: true
  workloadSelector:
    labels:
      app: application
